# FSD 멘탈 모델 가이드 (FSD-Mental-model.md)

이 문서는 Feature-Sliced Design (FSD) 아키텍처를 이해하고 적용하는 데 필요한 핵심 개념, 철학적 배경, 그리고 구체적인 코드 경계 기준을 제공합니다. FSD는 프론트엔드 애플리케이션의 **일관성, 유지보수성, 확장성을 높이는 현대적인 구조화 방법론**입니다.

## 1. FSD의 핵심 철학 및 멘탈 모델

FSD는 단순히 파일을 정리하는 것을 넘어, **개발자가 프로젝트의 구조와 각 부분의 연결을 직관적으로 이해하고 예측할 수 있도록** 돕는 멘탈 모델(Mental Model) 역할을 합니다. 잘 설계된 구조는 개발자의 **인지 부하를 줄여** 생산성을 극대화하는 전략적 자산이 됩니다.

| 철학                     | 설명                                                                                                                                                                                                  |
| :----------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **관심사의 세밀한 분리** | 역할뿐만 아니라 도메인, 기능, 데이터 흐름 등 다양한 관점의 관심사를 세밀하게 분리한다. FSD의 계층(Layer)은 소프트웨어 공학의 **관심사의 분리(Separation of Concerns)** 원칙을 구현한 것으로 해석된다. |
| **예측 가능한 컨벤션**   | 명확한 구조화 규칙을 제공하여 파일의 위치를 쉽게 예측할 수 있게 하며, 팀원 간의 협업을 원활하게 한다. 이는 **폴더 이름과 구조에 대한 고민 에너지를 덜어주려는 목적**이 있다.                          |
| **일관성**               | 폴더 구조는 **팀 컨벤션의 역할**을 하기에 예측 가능해야 하며, 정해진 경계를 **일관되게 유지하는 것**이 매우 중요하다. 경계를 정하고 유지하는 일관성이 분리의 감각보다 더 중요할 수 있다.              |
| **응집도와 결합도**      | **높은 응집도(High Cohesion)**와 **낮은 결합도(Low Coupling)**를 달성하여 시스템의 한 부분이 변경될 때 다른 부분에 미치는 영향을 최소화한다.                                                          |
| **AI 시대의 역할**       | 코드 정리와 정돈은 아직까지 AI보다 개발자가 더 잘할 수 있는 영역이며, FSD는 이러한 체계적인 방법론을 제공한다.                                                                                        |

---

## 2. FSD의 구조적 세 축 (3 Axes)

FSD는 세 가지 축을 결합하여 코드를 구조화하는 방식을 제안하며, 이 구조를 통해 아키텍처 부패를 막고 시스템의 안정성을 유지하려 합니다.

| 축                     | 역할                                                 | 설명                                                                                                                                                      |
| :--------------------- | :--------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **레이어 (Layer)**     | 기능적 역할에 따른 수직적 관심사 분리 (책임과 범위). | **의존성 원칙:** 상위 레이어는 하위 레이어를 가져올 수 있지만, 그 반대는 불가능하다. 이는 순환 의존성을 방지한다.                                         |
| **슬라이스 (Slice)**   | 비즈니스 도메인별 관심사 분리.                       | 프로젝트의 기능을 중심으로 코드를 그룹화한다 (예: `user`, `product`, `cart`). 같은 레이어 내의 슬라이스들은 서로를 직접 가져올 수 없어 모듈성을 강제한다. |
| **세그먼트 (Segment)** | 기술적 관심사 분리.                                  | 도메인 코드 내부를 기술적 역할로 명확하게 구조화한다 (예: `api`, `model`, `ui`).                                                                          |

---

## 3. FSD 레이어별 책임 및 특징

레이어 이름(`Layer`)과 세그먼트 이름(`Segment`)은 **가급적 변형하거나 늘리지 말고 그대로** 사용해야 한다.

| 레이어       | 목적 및 책임                                                                 | 핵심 특징/멘탈 모델                                                                                               |
| :----------- | :--------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------- |
| **app**      | 애플리케이션의 전역 설정 (라우팅, 스토어 초기화, 전역 스타일 등).            | **프로젝트 전용.** 프로젝트 내부에서만 사용되는 전역적인 공통 설정/컴포넌트.                                      |
| **pages**    | 사용자와 상호작용하는 실제 페이지 컴포넌트.                                  | 경로 단위의 구조를 표현하며, **위젯, 기능, 엔터티를 통합**한다. 페이지는 라우팅의 진입점 역할을 한다.             |
| **widgets**  | 여러 기능(features)이나 UI 요소를 독립적인 단위로 조합한 컴포넌트.           | **독립적인 단위.** 조립(composition)이 핵심이며, 자체적으로 새로운 이벤트 핸들러나 복잡한 로직을 생성하지 않는다. |
| **features** | 특정 **사용자 행동**과 관련된 비즈니스 로직 및 상태 관리.                    | **행동 중심적 (Action-Driven).** 하나의 기능은 하나의 주요 사용자 행동을 포함해야 한다.                           |
| **entities** | 핵심 비즈니스 엔티티와 관련된 코드 (데이터 모델, 타입 정의, 기본 CRUD 연산). | **순수성 (Purity) & 데이터 중심적.** 간단하고 독립적이며 부작용(Side effects)이나 상태 관리가 없다.               |
| **shared**   | 공통 유틸리티와 컴포넌트를 포함.                                             | **재사용 가능 & 범용성.** 여러 프로젝트에서도 재사용 가능한 요소.                                                 |

---

## 4. 세그먼트별 경계 및 규칙

세그먼트는 각 슬라이스(도메인) 내에서 기술적 관심사를 분리하는 기준입니다.

| 세그먼트   | 책임                                   | 구체적인 경계 및 규칙                                                                                                                                                                                                         |
| :--------- | :------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **ui**     | 순수 표현 컴포넌트.                    | `.tsx`, `.vue` 등의 컴포넌트 파일. 스타일과 레이아웃만 담당하는 **순수 UI 컴포넌트**이며, **`shared/ui`만** 이벤트 핸들러나 스타일링 props를 받을 수 있다. 그 외의 컴포넌트는 **도메인 데이터만** props로 받는 것을 권장한다. |
| **api**    | 외부 서비스와의 통신.                  | `fetch`, `webSocket` 등 외부 통신을 담당하며, API 엔드포인트 정의 및 데이터 변환 로직을 포함한다. 서버 상태 관리를 위한 TanStack Query와 같은 도구를 사용할 수 있다.                                                          |
| **model**  | 비즈니스 로직, 상태 관리, 데이터 구조. | 일반적인 커스텀 훅, 상태 관리 로직, 도메인과 연관된 함수를 포함한다. **Entity 레이어의 model은 순수 함수와 타입 정의만** 포함하고 부작용이 없어야 한다.                                                                       |
| **lib**    | 순수 함수와 도메인 특화 헬퍼 함수.     | **model과의 구분:** 함수의 인자에서 비즈니스 도메인을 쓰지 않는 유틸리티 함수(예: `formatDate`, `deepClone`)를 포함한다.                                                                                                      |
| **config** | 프로젝트 전반에 걸친 설정 값과 상수.   | 동작이 전혀 없는 상수들의 모음. 환경별 설정값, 도메인별 규칙과 제약조건 설정 등이 포함된다.                                                                                                                                   |

---

## 5. FSD 적용 멘탈 모델 및 팁

1.  **점진적인 확장 및 실용성:** FSD는 대규모 코드베이스에 유용하므로, 처음부터 모든 경계를 억지로 만들려 하기보다 **코드가 커질 때마다 적절히 가지치기 해가듯 확장**하는 것이 핵심이다. 단순한 기능 기반 구조는 FSD의 덜 엄격한 형태로 간주될 수 있으며, 프로젝트의 성격에 맞게 유연하게 구조를 조정해야 한다.
2.  **경계의 선명화 (책임 중심 사고):** "이것이 feature인가 entity인가?"를 고민하기보다 **"이 코드가 어떤 책임을 지니고 있는가?"**를 먼저 생각하고 분리해야 한다.
    - **Entity:** 데이터 중심, 순수성. **데이터 자체의 기본 표현**에 집중한다.
    - **Feature:** 행동 중심, 상태 변경. **특정 사용자 행동의 맥락**에서 데이터를 처리한다.
    - **Widget:** 화면 중심, 조립. **여러 컴포넌트를 조합하여 하나의 의미있는 화면 구획**을 만드는 것에 집중한다.
3.  **예측 가능성 훈련:** Layer, Slice, Segment의 조합식(예: `features/cart/model`)을 통해 **코드의 경계를 예측해보는 훈련**은 팀 컨벤션을 맞추고 경계를 선명하게 하는 데 큰 도움이 된다. 이는 REST API의 명사(리소스)와 동사(HTTP 메서드) 조합처럼 예측 가능한 구조를 만드는 것과 유사하다.
4.  **공개 API 강제:** 각 슬라이스는 `index.ts` 파일을 통해 자신의 **공개 API(Public API)**를 외부에 노출해야 하며, 다른 모듈은 오직 이 파일을 통해서만 기능에 접근하여 내부 구현을 캡슐화해야 한다.
5.  **도구의 활용:** 대규모 프로젝트에서는 Plop.js를 이용한 **자동화된 스캐폴딩**으로 구조의 일관성을 유지하고, ESLint의 `no-restricted-imports` 규칙이나 `eslint-plugin-boundaries` 같은 플러그인을 사용하여 **계층 간 의존성 규칙을 자동으로 강제**하는 것이 필수적이다.

## 6. FSD의 소프트웨어 공학적 해석

FSD 구조는 검증된 소프트웨어 공학 원칙들을 프론트엔드 아키텍처에 응용한 것이다.

| 원칙                                                       | FSD 레이어와의 관계                                                                                                                                                      |
| :--------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **단일 책임 원칙 (Single Responsibility Principle, SRP)**  | 각 레이어가 명확한 하나의 책임만 지도록 설계되어 있어, 변경의 이유가 하나가 되도록 한다.                                                                                 |
| **관심사의 분리 (Separation of Concerns, SoC)**            | `entities` (데이터), `widgets` (화면 구성), `features` (사용자 행동)가 각각 다른 관심사를 다루도록 설계되었다.                                                           |
| **의존성 역전 원칙 (Dependency Inversion Principle, DIP)** | `Pages` → `Widgets` → `Features` → `Entities` → `Shared` 의 방향으로 의존성을 가져가, 상위 모듈이 하위 모듈에 의존하는 구조를 만든다. 이로써 변경의 파급효과를 제한한다. |
