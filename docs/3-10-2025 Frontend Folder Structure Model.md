# 3-10. 2025 프론트엔드 폴더 구조 모델

[폴더구조의 변화로 이해하는 프론트엔드 멘탈모델 변천사](https://velog.io/@teo/folder-structure)

> 위 글은 제가 쓴 글이에요. 위 글와 아래 내용은 서로 연관은 있지만 다른 내용입니다. 한 마디로 둘 다 읽어보라는 말이에요. 😊

# Part 1: 현대적인 폴더 구조의 기초

여러분이 프론트엔드 개발을 하다 보면 "파일을 어디에 둬야 하지?"라는 질문을 자주 하게 됩니다. 현대 프론트엔드 개발에서 폴더 구조는 단순히 파일을 정리하는 것을 넘어서, 프로젝트의 아키텍처와 정신 모델을 물리적으로 구현하는 핵심적인 설계 활동이 되었습니다. 잘 설계된 구조는 코드의 복잡성을 관리하고, 팀원들과 협업을 원활하게 하며, 개발자의 인지 부하를 줄여 생산성을 극대화하는 전략적 자산이 됩니다. 이건 단순히 보기 좋게 만드는 문제가 아니라, 장기적으로 프로젝트의 성공과 실패를 가를 수 있는 중요한 엔지니어링 결정입니다.

### 1.1. 핵심 원칙: 파일 구성을 넘어서

성공적인 폴더 구조를 만들기 위해서는 몇 가지 핵심적인 소프트웨어 설계 원칙을 이해해야 합니다. 이 원칙들은 코드를 논리적으로 그룹화하고 모듈 간의 의존성을 관리하여, 변화에 유연하고 확장하기 쉬운 시스템을 만드는 데 도움을 줍니다.

### 높은 응집도와 낮은 결합도 (High Cohesion & Low Coupling)

> 소프트웨어 설계를 배울 때 가장 먼저 알아야 할 두 원칙이 바로 높은 응집도와 낮은 결합도입니다.

- **높은 응집도 (High Cohesion) :** 인증(Authentication) 기능을 구현한다고 생각해보세요. 전통적인 '타입 기반' 구조에서는 인증 관련 컴포넌트는 `/components` 폴더에, 관련 훅(hook)은 `/hooks` 폴더에, API 호출 로직은 `/services` 폴더에 흩어져 있게 됩니다. 이렇게 되면 낮은 응집도를 갖게 되는 거죠. 반면, '기능 기반' 구조를 배우면 `/features/auth`라는 폴더를 만들고 그 안에 인증 기능에 필요한 컴포넌트, 훅, 서비스 로직을 모두 함께 둡니다. 이렇게 하면 특정 기능을 수정하거나 이해해야 할 때 한 곳만 살펴보면 되므로 코드의 가독성과 유지보수성이 크게 향상됩니다.

- **낮은 결합도 (Low Coupling):** 시스템의 한 부분이 변경될 때 다른 부분에 미치는 영향을 최소화하는 원칙입니다. 이를 달성하려면 모듈이 서로의 내부 구현에 깊이 의존하지 않고, 잘 정의된 인터페이스를 통해서만 상호작용하도록 해야 합니다. 예를 들어 각 기능 모듈이 명확한 '공개 API(Public API)'를 가지고, 다른 모듈은 오직 이 API를 통해서만 해당 기능에 접근하도록 하는 것이 좋은 방법입니다. 한 모듈의 내부 파일 구조가 변경되더라도 공개 API가 동일하게 유지된다면, 해당 모듈을 사용하는 다른 코드들은 전혀 영향을 받지 않습니다. 이것이 코드의 유연성과 재사용성을 높이는 핵심입니다.

### DRY 원칙(코드 중복 방지)를 위한 성급한 추상화는 괴물 컴포넌트를 만든다.

DRY 원칙은 코드 중복을 피하라는 유용한 지침이지만, 이를 맹목적으로 적용하면 오히려 문제가 될 수 있다는 것을 알아야 합니다. 너무 이르거나 잘못된 추상화는 약간의 코드 중복보다 더 큰 문제를 일으킬 수 있습니다. 예를 들어, 단지 코드 몇 줄이 비슷하다는 이유로 성급하게 공통 컴포넌트를 만들면, 각기 다른 요구사항을 수용하기 위해 수많은 속성(props)을 받는 "괴물 컴포넌트"가 만들어질 수 있습니다.

**2025년의 프론트엔드 개발을 배우는 여러분은 DRY 원칙을 보다 미묘하게 해석하는 법을 익혀야 합니다.** 진정으로 재사용 가능하고 안정적인 로직(예: 디자인 시스템의 버튼, 날짜 포맷 유틸리티)은 공유 계층(shared layer)에 두어 중복을 피하는 것이 바람직합니다. 하지만 서로 다른 비즈니스 로직에 속해 있어 미래에 각기 다른 방향으로 변경될 가능성이 있는 코드라면, 약간의 중복을 감수하고 각 기능 폴더 내에 독립적으로 유지하는 것이 더 나은 선택일 수 있습니다. 잘못된 추상화와 싸우기보다는 약간의 중복을 허용하는 것이 장기적으로 유지보수 비용을 줄일 수 있다는 점을 기억하세요.

### 개발자 경험(DX)과 온보딩

잘 설계된 폴더 구조는 개발자 경험(DX)을 크게 향상시킨다는 것을 배우게 될 것입니다. 명확하고 일관된 구조는 프로젝트의 전체적인 그림을 쉽게 파악하게 해주며, 새로운 팀원이 합류했을 때 온보딩 과정을 단축시키는 효과가 있습니다. 개발자가 특정 기능을 찾기 위해 여러 디렉토리를 헤매지 않아도 되고, 파일의 위치만으로 그 역할을 유추할 수 있게 되면, 불필요한 인지 부하가 줄어들어 더 중요한 비즈니스 로직 구현에 집중할 수 있게 됩니다.

### 1.2. 확장성 스펙트럼: 프로토타입에서 엔터프라이즈까지

프로젝트의 규모와 복잡성이 증가함에 따라 폴더 구조에 대한 요구사항도 진화한다는 것을 이해하는 것이 중요합니다. 모든 프로젝트에 맞는 단 하나의 "최고의" 구조는 존재하지 않으며, 프로젝트의 현재 단계와 미래의 성장 가능성을 고려한 상황에 맞는 선택이 필요합니다.

### 레벨 1: 역할 기반의 플랫 구조 (소규모 프로젝트 및 프로토타입)

여러분이 아주 작은 프로젝트나 아이디어를 빠르게 검증하기 위한 프로토타입을 만들 때는 파일을 타입별로 그룹화하는 단순하고 평평한(flat) 구조가 효과적입니다. create-react-app이나 Vite 같은 도구들이 기본적으로 제공하는 구조처럼 `/components`, `/hooks`, `/utils` 등의 폴더를 사용하는 방식을 배우게 될 것입니다. 이 단계에서는 속도와 단순함이 가장 중요한 가치입니다.

**한계**: 이 구조는 프로젝트가 조금만 커져도 금방 관리하기 어려워진다는 것을 경험하게 될 것입니다. 각 폴더에 파일이 수십 개씩 쌓이면 관련 파일을 찾기 힘들어지고, 하나의 비즈니스 로직이 여러 디렉토리에 흩어져 있어 전체적인 흐름을 파악하기 어렵게 됩니다. 이는 낮은 응집도로 인한 전형적인 문제입니다.

### 레벨 2: 기능 그룹화 구조 (중대규모 프로젝트)

프로젝트를 확장하기 위해 배워야 할 가장 중요하고 첫 번째 단계는 기능(feature) 또는 도메인(domain)을 기준으로 코드를 그룹화하는 것입니다. `/features/auth`, `/features/dashboard`와 같은 폴더를 만들고, 각 폴더 안에 해당 기능에만 사용되는 컴포넌트, 훅, 서비스 등을 배치하는 방식을 익히게 됩니다.

**장점**: 이 접근법을 배우면 응집도를 극적으로 향상시킬 수 있습니다. 특정 기능과 관련된 모든 코드가 한곳에 모여 있기 때문에, 기능을 이해하거나 리팩토링하거나 심지어 제거하는 작업이 매우 용이해집니다. 이는 프로젝트의 유지보수성을 크게 높이는 효과를 가져옵니다.

### 레벨 3: 엄격하게 강제되는 아키텍처 (대규모 및 엔터프라이즈 프로젝트)

여러 팀이 참여하는 매우 크고 장기적인 프로젝트에서는 단순히 기능별로 그룹화하는 것만으로는 부족하다는 것을 배우게 됩니다. 시간이 지남에 따라 아키텍처가 무너지는 '아키텍처 부패(architectural decay)' 현상을 막기 위한 강력한 규칙이 필요합니다. 이 단계에서는 Feature-Sliced Design(FSD)과 같은 엄격한 아키텍처 방법론을 학습하게 됩니다. FSD는 계층(layer) 간의 의존성 흐름을 엄격하게 통제하여 시스템의 안정성을 유지하고 예측 가능성을 높입니다.

**요구사항**: 이 수준의 아키텍처를 유지하기 위해서는 팀의 높은 이해도와 규율뿐만 아니라, 아키텍처 규칙을 자동으로 강제하는 도구(예: 린터, 코드 생성기)의 도입이 필수적이라는 것을 배우게 됩니다.

이러한 스펙트럼을 이해하면 폴더 구조를 정적인 것이 아닌, 프로젝트의 생명주기에 따라 진화하는 동적인 것으로 바라보게 됩니다. 초기에는 단순한 구조로 시작하더라도, 프로젝트가 성장함에 따라 발생하는 문제점(pain point)을 해결하기 위해 점진적으로 더 구조화된 방식으로 전환하는 전략을 배우는 것이 중요합니다.

이 과정에서 폴더 구조는 단순한 파일 정리 체계를 넘어, 아키텍처의 대리인(proxy) 역할을 수행한다는 것을 이해하게 됩니다. 개발자가 코드를 배치하는 방식은 곧 시스템의 의존성과 복잡성을 관리하는 방식에 대한 선언과 같습니다. 예를 들어, '타입 기반' 구조에서 '기능 기반' 구조로 전환하는 것은 단순히 파일을 옮기는 것이 아니라, 응집도를 높이고 결합도를 낮추려는 명확한 아키텍처적 결정입니다. 더 나아가 FSD를 도입하는 것은 아키텍처 부패를 막기 위한 더욱 진보된 아키텍처적 결정이라는 것을 배우게 됩니다.

또한, 실용적인 관점에서 배워야 할 중요한 점은 대부분의 성공적인 아키텍처는 순수한 형태가 아닌 하이브리드 모델을 채택한다는 것입니다. 기능 기반 구조에서도 전역적으로 사용되는 UI 컴포넌트나 유틸리티 함수를 위한 `/shared`, `/lib`, `/core`와 같은 최상위 공유 디렉토리는 반드시 필요합니다. 진정으로 재사용 가능한 자산을 특정 기능 폴더 내에 두는 것은 잘못된 의존성을 만들어내기 때문입니다. 따라서 가장 실용적이고 확장 가능한 아키텍처는 비즈니스 로직을 위한 기능 기반 그룹화와, 애플리케이션에 특화되지 않은 범용 유틸리티 및 UI 요소를 위한 잘 정의된 공유 계층을 결합하는 형태가 된다는 것을 배우게 됩니다. 여기서 핵심 과제는 '어떤 코드가 특정 기능에 속하고, 어떤 코드가 공유되어야 하는가'에 대한 명확한 경계를 설정하는 방법을 익히는 것입니다.

## Part 2: 주요 아키텍처 방법론: 비교 분석

프론트엔드 아키텍처 분야를 공부하다 보면 복잡성을 관리하고 코드의 품질을 높이기 위한 여러 가지 성숙한 방법론들을 만나게 됩니다. 이들은 각기 다른 철학을 바탕으로 하지만, 모두 확장 가능하고 유지보수하기 쉬운 애플리케이션을 구축한다는 공통된 목표를 가집니다. 여기서는 가장 영향력 있는 세 가지 방법론인 아토믹 디자인, 도메인 주도 설계, 그리고 피처 슬라이스 디자인을 자세히 배워보겠습니다.

### 2.1. 컴포넌트 중심 접근법: 아토믹 디자인 (Atomic Design)

**철학**: 브래드 프로스트(Brad Frost)에 의해 소개된 아토믹 디자인을 배우면, UI를 다섯 단계의 뚜렷한 계층으로 분해하여 디자인 시스템을 구축하는 방법을 익히게 됩니다. 이는 UI를 하나의 응집력 있는 전체이면서 동시에 여러 부분의 집합으로 생각하는 정신 모델을 제공합니다. 화학의 원자, 분자, 유기체 개념을 차용하여 컴포넌트의 계층 구조를 명확하게 정의하는 방법을 배우게 됩니다.

**5단계 계층**

**원자 (Atoms)**: UI의 가장 기본적인 구성 요소로, 더 이상 분해할 수 없는 최소 기능 단위를 배우게 됩니다. 예를 들어 버튼, 인풋 필드, 레이블, 아이콘과 같은 HTML 요소나 색상 팔레트, 폰트와 같은 디자인 속성이 여기에 해당합니다.

**분자 (Molecules)**: 여러 개의 원자가 결합하여 하나의 단위로 함께 기능하는 단순한 그룹을 만드는 방법을 배웁니다. 예를 들어, 레이블 원자, 인풋 원자, 버튼 원자가 결합하여 검색 폼 분자를 구성할 수 있습니다. 이 단계의 컴포넌트는 단일 책임 원칙을 따르는 재사용 가능한 단위가 됩니다.

**유기체 (Organisms)**: 분자와 원자, 또는 다른 유기체가 결합하여 형성되는 더 복잡하고 독립적인 인터페이스의 한 부분을 만드는 방법을 익힙니다. 웹사이트의 헤더는 로고(원자), 주 메뉴(분자), 검색 폼(분자)이 결합된 유기체의 좋은 예입니다.

**템플릿 (Templates)**: 실제 콘텐츠 없이 페이지의 전체적인 레이아웃과 구조를 정의하는 단계를 배웁니다. 여러 유기체와 분자를 배치하여 페이지의 뼈대를 만듭니다. 이는 동적인 콘텐츠가 채워질 것을 대비하여 설계의 일관성을 유지하는 데 중요한 역할을 합니다.

**페이지 (Pages)**: 템플릿에 실제 콘텐츠(텍스트, 이미지 등)를 채워 넣어 사용자에게 보여지는 최종 UI의 구체적인 인스턴스를 만드는 방법을 배웁니다. 이 단계를 통해 디자인 시스템이 실제 데이터와 만났을 때 얼마나 효과적이고 견고한지 테스트할 수 있습니다.

**폴더 구조 구현 방법을 배워봅시다**: 이 방법론은 `/components` 또는 `/ui` 디렉토리 내에서 직관적인 폴더 구조로 변환될 수 있습니다.

```
/src
  └── /components
      ├── /1_atoms
      │   ├── Button.tsx
      │   └── Input.tsx
      ├── /2_molecules
      │   └── SearchForm.tsx
      ├── /3_organisms
      │   └── PageHeader.tsx
/src
  ├── /4_templates
  │   └── HomepageTemplate.tsx
  └── /5_pages
      └── HomePage.tsx

```

**밝혀진 장단점:**
아토믹 디자인은 디자인 시스템이나 컴포넌트 중심의 애플리케이션을 구축하고 유지보수하는 데 매우 효과적이라는 것을 배우게 됩니다. 재사용성과 일관성을 극대화하는 장점이 있습니다.

하지만 소규모 프로젝트에서는 과도한 계층 구조로 인해 불필요한 복잡성을 초래할 수 있으며, 비즈니스 로직이나 데이터 흐름을 어떻게 구성할지에 대한 해답을 제공하지는 않는다는 한계도 알아두어야 합니다.

이 때문에 아토믹 디자인은 독립적인 아키텍처라기보다는, 다른 아키텍처 내에서 UI 컴포넌트를 체계적으로 관리하기 위한 패턴으로 사용되는 경우가 많습니다(예: FSD의 shared/ui 세그먼트).

### 2.2. 비즈니스 중심 접근법: 도메인 주도 설계 (Domain-Driven Design, DDD) 원칙

DDD는 소프트웨어의 구조를 비즈니스 도메인에 맞추는 것을 목표로 하는 개발 접근법이라는 것을 배우게 됩니다. 개발자와 도메인 전문가가 공유하는 '유비쿼터스 언어(Ubiquitous Language)'를 통해 소통하고, 이를 코드에 직접 반영하는 것을 강조합니다. 본래 백엔드에서 시작되었지만, 복잡한 비즈니스 로직을 다루는 현대 프론트엔드 애플리케이션에서도 그 원칙이 활발히 적용되고 있다는 것을 알게 될 것입니다. DDD의 핵심은 기술이 아닌 '제품'과 '비즈니스' 자체에 집중하는 것입니다.

**프론트엔드를 위한 DD 핵심 개념을 톺아보기**

**바운디드 컨텍스트 (Bounded Context)**: 특정 도메인 모델이 적용되는 명확한 경계를 의미한다는 것을 배웁니다. 프론트엔드에서는 하나의 주요 기능 영역이나 마이크로 프론트엔드가 하나의 바운디드 컨텍스트에 해당할 수 있습니다.

**도메인 (Domain) 및 하위 도메인 (Subdomain)**: 도메인은 애플리케이션이 다루는 비즈니스 영역(예: 전자상거래, 헬스케어)을 의미한다는 것을 배웁니다. 전략적 설계를 통해 도메인을 더 작은 하위 도메인으로 나누고, 각각을 핵심(Core, 경쟁 우위), 지원(Supporting), 일반(Generic, 표준 솔루션)으로 분류하여 자원을 집중할 곳을 결정하는 방법을 익히게 됩니다.

**폴더 구조 구현 방법**: DDD에서 영감을 받은 폴더 구조는 기술적 역할이 아닌 비즈니스 하위 도메인을 기준으로 코드를 구성한다는 것을 배웁니다. 이는 자연스럽게 높은 응집도를 이끌어냅니다.

```
/src
  └── /domains             // 또는 /features, /modules
      ├── /ordering
      │   ├── /entities    // Order, OrderItem 모델
      │   ├── /useCases    // PlaceOrder, CancelOrder 로직
      │   ├── /components  // OrderForm, OrderHistory 컴포넌트
      │   └── /services    // 주문 관련 API 호출
      ├── /catalog
      │   ├── /entities    // Product 모델
      │   ├── /useCases    // SearchProducts 로직
      │   └── /components  // ProductGrid, ProductDetail 컴포넌트
      └── /shared-kernel   // CustomerID, Money 등 공유 개념

```

**밝혀진 장단점:**
DDD는 비즈니스 로직이 복잡하고 명확하게 정의된 대규모 애플리케이션에 매우 적합하다는 것을 배우게 됩니다. 비즈니스 도메인을 이해하는 개발자에게는 코드가 매우 직관적으로 다가옵니다. 하지만 깊은 도메인 지식을 요구하며, 팀이 '프론트엔드'를 제품 도메인의 일부가 아닌 별개의 기술적 바운디드 컨텍스트로 오해할 경우 잘못 적용될 위험이 있다는 점도 알아두어야 합니다.

### 2.3. 기능 중심 접근법: 피처 슬라이스 디자인 (Feature-Sliced Design, FSD)

**철학**: FSD는 프론트엔드 애플리케이션을 스캐폴딩하기 위한 엄격한 아키텍처 방법론으로, 프로젝트가 확장됨에 따라 코드베이스를 이해하기 쉽고 안정적으로 유지하기 위해 설계되었다는 것을 배우게 됩니다. 코드를 계층(Layers), 슬라이스(Slices), 세그먼트(Segments)라는 세 가지 축으로 구성하고, 이들 간의 의존성에 대한 엄격한 규칙을 적용합니다.

**핵심 계념 톺아보기**

**계층 (Layers)**: FSD는 총 7개의 계층으로 구성되며, 상위 계층은 하위 계층을 가져올 수 있지만 그 반대는 불가능한 계층적 구조를 가진다는 것을 배웁니다. 이 규칙은 순환 의존성을 방지하고 변경의 영향을 국소화합니다.

- **app**: 애플리케이션의 진입점으로, 초기화, 라우팅, 전역 스타일 및 스토어 설정 등을 담당합니다.
- **pages**: 완전한 애플리케이션 페이지로, 위젯과 기능들로 구성됩니다.
- **widgets**: 독립적이고 큰 UI 블록입니다 (예: 헤더, 사이드바, 게시물 댓글 목록).
- **features**: 사용자 상호작용과 관련된 비즈니스 가치를 제공하는 로직입니다 (예: 인증, 댓글 달기, 장바구니에 추가).
- **entities**: 애플리케이션이 다루는 비즈니스 개체, 즉 '명사'입니다 (예: 사용자, 제품, 댓글).
- **shared**: 비즈니스 로직과 무관한 재사용 가능한 코드입니다 (예: UI 키트, API 클라이언트, 유틸리티 함수).

**슬라이스 (Slices)**: 계층 내에서 비즈니스 도메인을 기준으로 코드를 그룹화하는 폴더라는 것을 배웁니다 (예: features/authentication, entities/user). 같은 계층 내의 슬라이스들은 서로를 직접 가져올 수 없어 모듈성을 강제합니다.

**세그먼트 (Segments)**: 각 슬라이스는 기술적 목적에 따라 코드를 분리하는 표준화된 하위 폴더로 나뉜다는 것을 익히게 됩니다 (예: ui, model, api, lib, config).

**공개 API (Public API)**: 각 슬라이스는 반드시 index.ts 파일을 통해 자신의 공개 API를 외부에 노출해야 한다는 중요한 규칙을 배웁니다. 애플리케이션의 다른 부분은 오직 이 파일을 통해서만 해당 슬라이스의 기능에 접근할 수 있으며, 이를 통해 슬라이스의 내부 구현을 완벽하게 캡슐화합니다.

**밝혀진 장단점:**

**장점**: 확장성이 매우 뛰어나고 구조가 통일되어 있어 대규모 팀과 장기 프로젝트에 이상적이라는 것을 배우게 됩니다. 일단 학습하고 나면 새로운 팀원의 온보딩이 용이하며, 코드 재사용이 통제되고 리팩토링이 안전합니다.

**단점**: 학습 곡선이 가파르고 초기 설정이 복잡하다는 점을 알아두어야 합니다. 소규모 프로젝트에는 과도한 설계(over-engineering)가 될 수 있으며, 기존 프로젝트를 FSD로 마이그레이션하는 것은 매우 어려운 작업입니다. 때로는 규칙이 너무 엄격하게 느껴질 수도 있습니다.

### 2.4. 종합 및 하이브리드 모델

이 세 가지 방법론은 상호 배타적이지 않으며, 오히려 서로를 보완하며 함께 사용될 때 강력한 시너지를 낼 수 있다는 것을 배우게 됩니다.

**사례 1: FSD 내에서의 아토믹 디자인**: shared/ui 세그먼트를 아토믹 디자인 원칙에 따라 구성하는 것은 매우 일반적이고 효과적인 패턴이라는 것을 익히게 됩니다. atoms, molecules, organisms가 애플리케이션의 다른 부분에서 소비하는 UI 키트가 됩니다.

**사례 2: FSD 슬라이스 정의를 위한 DDD**: DDD의 비즈니스 하위 도메인과 엔티티를 식별하는 과정은 FSD의 entities와 features 계층에 대한 슬라이스를 정의하는 훌륭한 출발점이 될 수 있다는 것을 배웁니다. DDD가 '무엇'을 정의하고(예: User, Product), FSD가 '어디에' 배치할지를 결정하는 것입니다.

**사례 3: "FSD-Lite"로서의 기능 기반 구조**: 단순한 기능 기반 구조는 FSD의 7개 계층을 모두 사용하지 않고 features와 shared 개념만 차용한, 덜 엄격한 버전의 FSD로 볼 수 있다는 것을 이해하게 됩니다. 이는 많은 프로젝트에 실용적인 출발점을 제공합니다.

이러한 방법론들을 비교 분석해보면서 여러분은 중요한 통찰을 얻게 됩니다. 서로 다른 출발점에도 불구하고 결국에는 동일한 핵심 문제, 즉 대규모 UI 개발에서의 복잡성 관리, 경계 설정, 재사용성 향상을 해결하려 한다는 것을 알 수 있습니다. 아토믹 디자인은 UI 컴포넌트 수준에서, DDD는 비즈니스 로직 수준에서, FSD는 애플리케이션 전체 구조 수준에서 복잡성을 다룹니다. 따라서 가장 성숙한 아키텍처는 이 세 가지 방법론의 개념을 모두 차용할 가능성이 높다는 것을 배우게 됩니다.

또한, 이 모든 방법론에서 공통적으로 발견되는 중요한 패턴 중 하나는 모듈의 '공개 API' 개념이라는 것을 알게 됩니다. index.ts와 같은 배럴 파일을 사용하여 모듈의 진입점을 단일화하고 내부 구현을 숨기는 방식은, 채택한 아키텍처 방법론과 관계없이 확장성과 유지보수성을 확보하기 위한 보편적인 핵심 패턴입니다. 이는 낮은 결합도와 높은 캡슐화를 달성하는 가장 기본적인 메커니즘이라는 것을 기억하세요.

## Part 3: 모던 프레임워크 모범사례 살펴보기

추상적인 아키텍처 방법론을 실제 프로젝트에 적용하기 위해서는 사용하는 프레임워크의 특성을 고려한 구체적인 구현 계획이 필요하다는 것을 배우게 됩니다. 이 파트에서는 React, Next.js, Vue, Angular 등 주요 프레임워크 환경에서 각 아키텍처 원칙을 어떻게 구체적인 폴더 구조로 구현할 수 있는지 알아보겠습니다.

### 3.1. React & TypeScript 생태계

2025년 React 프로젝트의 표준으로 기능 기반(feature-based) 구조가 강력하게 권장된다는 것을 알아두세요. 이는 프로젝트가 성장함에 따라 유지보수성과 확장성을 확보하는 가장 실용적인 방법입니다. 아래는 많은 프로젝트에 적용할 수 있는 포괄적인 구조 예시입니다.

```
/src
  ├── /app              # 전역 설정: 라우팅, 프로바이더, 진입점
  ├── /components       # 또는 /shared/ui: 진정으로 재사용 가능한 전역 컴포넌트 (Button, Modal)
  ├── /features         # 기능별 모듈
  │   └── /authentication
  │       ├── /components # LoginForm, SignupForm 등 이 기능에서만 사용하는 컴포넌트
  │       ├── /hooks      # useAuth, useLogin 등 이 기능에 특화된 훅
  │       ├── /services   # authApi.ts 등 API 관련 로직
  │       ├── index.ts    # auth 기능의 공개 API (외부 노출)
  │       └── AuthPage.tsx  # 이 기능을 대표하는 페이지 컴포넌트
  ├── /hooks            # 전역적으로 공유되는 훅 (useLocalStorage, useTheme)
  ├── /lib              # 또는 /utils: 전역 유틸리티 함수 (날짜 포맷팅 등)
  ├── /services         # 전역 API 클라이언트, 외부 서비스 초기화
  ├── /store            # 전역 상태 관리 (Redux, Zustand)
  └── /types            # 전역 TypeScript 타입 정의

```

이 하이브리드 구조는 FSD처럼 엄격하지는 않으면서도 관심사의 분리를 명확하게 하여 많은 프로젝트에 이상적인 균형점을 제공한다는 것을 이해하게 됩니다. 각 디렉토리의 역할은 명확합니다. `/features`는 비즈니스 로직을 캡슐화하고, `/components`와 `/hooks` 같은 최상위 폴더는 여러 기능에 걸쳐 재사용되는 범용적인 코드를 보관합니다.

**전역 TypeScript 타입 정의**

- 전역적으로 사용되는 타입은 `/types` 폴더에 중앙 집중화하되, 특정 컴포넌트나 기능에만 사용되는 타입은 해당 컴포넌트/기능 폴더 내에 함께 배치(co-location)하는 것이 좋다는 것을 배웁니다.
- 전역 네임스페이스를 오염시킬 수 있는 `.d.ts` 파일의 남용을 피하고, 명시적인 import/export를 통해 타입을 관리해야 한다는 것을 알게 됩니다.
- 각 기능 모듈의 공개 API인 index.ts 파일을 통해 컴포넌트, 훅뿐만 아니라 관련 타입도 함께 내보내어 사용성을 높이는 방법을 익히게 됩니다.

### 3.2. Next.js: App Router 탐색

Next.js 13 이상에서 도입된 App Router는 파일 시스템 기반 라우팅을 통해 프로젝트 구조를 근본적으로 정의한다는 것을 배우게 됩니다. 폴더는 URL 경로 세그먼트를 정의하고, page.tsx, layout.tsx, loading.tsx, error.tsx와 같은 특수 파일들은 해당 경로의 UI를 구성합니다.

**특징1. Co-location**

App Router는 컴포넌트, 스타일, 테스트 파일 등을 사용하는 라우트와 같은 폴더에 배치하는 co-location을 장려한다는 것을 알게 됩니다. 이는 자연스럽게 기능 기반 아키텍처와 잘 맞아떨어집니다.

**특징2. 라우트 그룹을 통한 구성**

URL 경로에 영향을 주지 않으면서 라우트를 논리적으로 그룹화하거나, 특정 그룹에만 공유 레이아웃을 적용하기 위해 괄호로 폴더 이름을 감싸는 '라우트 그룹(Route Groups)'은 매우 중요한 기술이라는 것을 배웁니다. 예를 들어 (marketing)이나 (shop) 같은 폴더를 만들어 관련 페이지들을 묶을 수 있습니다. 이는 Next.js가 제공하는 기능 도메인을 만드는 네이티브 메커니즘입니다.

**Next.js 에서 제안하는 모범 사례**

이러한 기능들을 활용한 구조는 코드 구성을 명확하게 하기 위해 src 디렉토리 내에 배치하는 것이 일반적이라는 것을 배웁니다.

```
/src
  ├── /app
  │   ├── /(marketing)      # 마케팅 페이지 라우트 그룹
  │   │   ├── /about
  │   │   │   └── page.tsx
  │   │   └── layout.tsx    # 마케팅 페이지들을 위한 레이아웃
  │   ├── /(shop)           # 메인 애플리케이션 라우트 그룹
  │   │   ├── /products
  │   │   │   └── page.tsx
  │   │   └── layout.tsx    # 메인 쇼핑몰을 위한 레이아웃
  │   ├── /api              # API 라우트
  │   └── layout.tsx        # 최상위 루트 레이아웃
  ├── /components           # 전역 공유 UI 컴포넌트 (Button 등)
  ├── /lib                  # 공유 유틸리티, DB 클라이언트 등
  ├── /features             # 페이지와 직접 관련 없는 비즈니스 로직/상태
  │   └── /cart
  │       ├── use-cart-store.ts
  │       └── index.ts
  └── /styles               # 전역 스타일

```

**모듈 기반 아키텍처**

대규모 Next.js 프로젝트에서는 '모듈 기반' 아키텍처가 효과적이라는 것을 배우게 됩니다. 이는 공유 로직을 위한 강력한 core 모듈과, 인증(authentication)과 같은 특정 기능을 캡슐화하는 여러 기능 모듈로 구성된 기능 기반 구조의 심화 버전입니다. 이 패턴은 Next.js 프로젝트의 확장성을 크게 향상시킨다는 것을 알게 됩니다.

### 3.3. Vue & Nuxt.js: 모듈성과 규칙 기반

React와 마찬가지로 대규모 Vue 애플리케이션에서는 기능 기반 또는 모듈식 구조가 권장된다는 것을 배웁니다. Vue 공식 스타일 가이드에서 권장하는 컴포넌트 이름은 파스칼 케이스(PascalCase)를 사용하고, 앱 전반에 걸쳐 사용되는 기본 컴포넌트에는 Base 접두사를 붙이는 등의 네이밍 컨벤션을 따르는 것이 좋다는 것을 알게 됩니다.

**Nuxt.js 디렉토리 구조**

Nuxt는 '규칙보다 설정(convention-over-configuration)' 철학을 바탕으로, 특정 폴더에 파일을 위치시키면 자동으로 필요한 기능이 활성화되는 강력한 디렉토리 구조를 가지고 있다는 것을 배웁니다.

- **components/**: Vue 컴포넌트를 저장하면 자동으로 임포트됩니다. 폴더를 중첩하여 `<BaseFooButton/>`과 같이 네임스페이스가 있는 컴포넌트를 만들 수 있다는 것을 배웁니다.
- **composables/**: Vue Composition API 함수(use...로 시작하는)를 저장하면 자동으로 임포트된다는 것을 알게 됩니다.
- **layouts/**: 여러 페이지에서 재사용 가능한 페이지 레이아웃을 정의하는 방법을 배웁니다.
- **pages/**: 파일 시스템 기반으로 애플리케이션의 라우트를 자동으로 생성한다는 것을 이해하게 됩니다.
- **assets/ vs public/**: 이 둘의 차이를 이해하는 것은 매우 중요합니다. assets 폴더에는 빌드 도구(Vite/Webpack)에 의해 처리될 파일(예: SCSS, 최적화가 필요한 이미지)을 넣고, public 폴더에는 빌드 과정 없이 서버 루트에 그대로 제공될 정적 파일(예: robots.txt, favicon.ico)을 넣는다는 것을 배웁니다.

**Nuxt가 제안하는 폴더구조 모범사례**

Vue 3에 권장되는 모듈식 접근법을 Nuxt의 규칙 기반 시스템에 적용한 구조를 배우게 됩니다.

```
/
  ├── /modules          # 기능별 모듈
  │   └── /products
  │       ├── /components # ProductCard, ProductFilter
  │       ├── /composables# useProducts (자동 임포트)
  │       └──...
  ├── /components       # 전역 컴포넌트 (BaseButton, BaseModal 등)
  ├── /composables      # 전역 컴포저블
  ├── /assets           # 스타일시트, 폰트 등 빌드 처리 대상
  ├── /public           # 정적 에셋
  ├── /layouts          # Default, Auth 레이아웃
  ├── /pages            # 라우팅을 위한 페이지
  └── nuxt.config.ts

```

### 3.4. Angular: 엔터프라이즈급 모듈성

Angular 아키텍처의 중심에는 캡슐화와 의존성 주입을 위한 공식적인 구조를 제공하는 NgModule 시스템이 있다는 것을 배웁니다. 표준적인 모범 사례는 '기능 모듈(feature module)' 아키텍처입니다.

**3가지 핵심 모듈 타입 (core / shared / features)**

**CoreModule**: 애플리케이션 전체에서 단 한 번만 인스턴스화되어야 하는 싱글톤 서비스(singleton service)와 단일 사용 컴포넌트(예: AppComponent, Header)를 포함한다는 것을 배웁니다. 이 모듈은 루트 모듈인 AppModule에서 단 한 번만 임포트되어야 합니다. 이는 서비스의 다중 인스턴스 생성을 방지합니다.

**SharedModule**: 여러 기능 모듈에서 공통으로 사용되는 재사용 가능한 컴포넌트, 디렉티브, 파이프를 포함한다는 것을 알게 됩니다. 이 모듈은 필요한 기능 모듈 어디에서든 임포트될 수 있습니다. 중요한 점은, SharedModule은 서비스를 제공(provide)해서는 안 된다는 것입니다.

**FeatureModule**: 특정 비즈니스 기능(예: UsersModule, OrdersModule)을 캡슐화한다는 것을 배웁니다. 기능 모듈은 공통 UI 요소를 위해 SharedModule을 임포트하고, 전역 서비스를 사용하기 위해 CoreModule에 의존합니다 (직접 임포트하는 것이 아니라, AppModule을 통해 제공받음).

**Angular가 제안하는 모범 사례**

폴더 구조는 이러한 모듈식 접근법을 직접적으로 반영하며, Angular CLI를 통해 쉽게 생성하고 관리할 수 있다는 것을 배웁니다.

```
/src
  ├── /app
  │   ├── /core
  │   │   ├── /guards       # AuthGuard
  │   │   ├── /services     # AuthService, LoggerService
  │   │   └── core.module.ts
  │   ├── /features
  │   │   └── /users
  │   │       ├── /components # UserListComponent, UserEditComponent
  │   │       ├── users.module.ts
  │   │       └── users-routing.module.ts
  │   ├── /shared
  │   │   ├── /components # ModalComponent, LoaderComponent
  │   │   ├── /pipes      # FormatDatePipe
  │   │   └── shared.module.ts
  │   ├── app.component.ts
  │   ├── app.module.ts
  │   └── app-routing.module.ts
  └── /assets

```

결론적으로 여러분이 배우게 될 중요한 통찰은, 각 프레임워크는 고유의 특성과 도구를 가지고 있지만, **현대 프론트엔드 개발의 큰 흐름은 모두 기능 기반의 모듈식 아키텍처를 지향하고 있다는 것입니다.**

과거에는 개발자의 선택에 맡겨졌던 구조화 방식이 이제는 프레임워크 자체에 내장된 기능(Next.js의 라우트 그룹, Angular의 모듈 시스템, Nuxt의 규칙 기반 자동화)을 통해 적극적으로 권장되고 있습니다. 이는 업계 전체가 과거의 평평한 구조에서 겪었던 고통을 통해 학습하고 발전한 결과이며, 이러한 흐름에 따르는 것이 프레임워크의 장점을 최대한 활용하고 장기적으로 성공적인 프로젝트를 구축하는 방법이라는 것을 배우게 됩니다.

## Part 4: 엔터프라이즈로의 확장: 모노레포와 도구

프로젝트의 규모가 커져 여러 애플리케이션과 라이브러리가 공존하고, 다수의 팀이 협업하는 엔터프라이즈 환경에 도달하면 코드 관리와 아키텍처 유지를 위한 새로운 차원의 전략이 필요하다는 것을 배우게 됩니다. 이 단계에서는 모노레포(Monorepo) 아키텍처와 아키텍처 규칙을 자동화하는 도구의 역할이 매우 중요해집니다.

### 4.1. 모노레포 아키텍처

**모노레포를 사용하는 이유**

모노레포는 여러 프로젝트의 소스 코드를 단일 저장소에서 관리하는 방식이라는 것을 배웁니다. 주요 장점으로는 UI 컴포넌트나 유틸리티 함수와 같은 코드의 손쉬운 공유, 공유 라이브러리 업데이트 시 모든 의존 프로젝트에 변경사항을 한 번에(atomically) 적용할 수 있는 점, 그리고 여러 프로젝트에 걸친 대규모 리팩토링의 용이성 등이 있습니다. 이는 공유 플랫폼을 기반으로 하거나 여러 개의 상호 연결된 애플리케이션을 개발하는 조직에 특히 이상적이라는 것을 알게 됩니다.

**핵심 구조: apps와 packages**

Turborepo나 Nx와 같은 현대적인 모노레포 관리 도구들은 표준적인 디렉토리 구조를 권장한다는 것을 익히게 됩니다. 이는 배포 가능한 애플리케이션과 공유 가능한 코드를 명확히 분리하는 것입니다.

**apps/**: 실제 사용자에게 배포될 최종 애플리케이션들이 위치하는 디렉토리라는 것을 배웁니다. 예를 들어, Next.js로 만든 웹사이트, Vite 기반의 관리자 대시보드, Storybook으로 구현된 문서 사이트 등이 여기에 해당합니다.

**packages/**: apps 디렉토리의 애플리케이션들이 공통으로 사용하는 공유 라이브러리들이 위치하는 디렉토리라는 것을 알게 됩니다. 이 패키지들은 독립적으로 배포되지 않고, 다른 애플리케이션에 의해 소비되는 것을 목적으로 합니다.

**일반적인 공유 패키지를 이해해봅시다**:

- **packages/ui**: 여러 애플리케이션에서 공통으로 사용되는 React, Vue 등의 UI 컴포넌트 라이브러리입니다. 이는 조직의 디자인 시스템의 핵심이 됩니다.
- **packages/tsconfig**: 여러 패키지에서 확장(extend)하여 사용할 수 있는 중앙 집중화된 TypeScript 설정을 제공하여 일관성을 유지합니다.
- **packages/eslint-config-custom**: 모든 앱과 패키지에 걸쳐 일관된 코딩 표준을 강제하기 위한 공유 ESLint 설정입니다.
- **packages/lib 또는 packages/utils**: 프레임워크에 종속되지 않는 순수한 유틸리티 함수들을 모아놓은 패키지입니다.

**모노레포를 위한 도구**

**ㅋ**모노레포를 효율적으로 관리하기 위해서는 Turborepo나 Nx와 같은 빌드 시스템이 필수적이라는 것을 알게 됩니다. 이 도구들은 변경된 부분만 빌드하고 테스트하는 '증분 빌드(incremental builds)', 빌드 결과를 저장하고 재사용하는 '캐싱(caching)', 그리고 패키지 간의 의존성 관계를 분석하는 '의존성 그래프 분석'과 같은 핵심 기능을 제공하여 대규모 저장소에서도 빠른 개발 속도를 유지할 수 있게 해줍니다.

모노레포 아키텍처는 기능 기반 구조와 매우 자연스럽게 결합된다는 것을 배우게 됩니다. 모노레포의 주된 목적인 코드 공유를 촉진하는 과정에서, 개발팀은 자연스럽게 무엇이 공유 가능한 package이고 무엇이 특정 애플리케이션에 속한 코드(apps)인지를 결정하게 됩니다. 이 과정 자체가 기능과 공유 코드의 경계를 명확히 하도록 유도하며, 모노레포의 물리적 구조가 아키텍처적 분리를 위한 가이드 역할을 하게 된다는 것을 이해하게 됩니다.

### 4.2. 폴더 구조를 위한 도구들

대규모 프로젝트에서 아키텍처 규칙은 단순히 문서나 구두 약속, 코드 리뷰만으로는 지켜지기 어렵다는 것을 배우게 됩니다. 시간이 지나고 팀원이 늘어남에 따라 아키텍처는 점차 무너지기 쉽습니다. 따라서 '올바른 방법'을 '쉬운 방법'으로 만들고, 규칙 위반을 원천적으로 방지하는 자동화된 도구의 도입이 필수적이라는 것을 알게 됩니다.

### Plop.js를 이용한 자동화된 스캐폴딩

**목적을 이해해봅시다**: Plop.js는 템플릿을 기반으로 새로운 파일과 폴더 구조를 생성해주는 "마이크로 제너레이터"라는 것을 배웁니다. 이를 활용하면 새로운 컴포넌트나 기능을 추가할 때마다 정해진 폴더 구조와 필요한 파일들(컴포넌트, 스타일, 테스트, 스토리북 등)이 일관되게 생성되도록 자동화할 수 있습니다. 이는 개발자의 반복 작업을 줄여줄 뿐만 아니라, 아키텍처의 일관성을 유지하는 데 결정적인 역할을 합니다.

**예시를 통해 배워봅시다**: 아래는 React 컴포넌트를 생성하는 plopfile.js와 관련 템플릿 예시입니다. 이 생성기는 컴포넌트 이름(ComponentName)을 입력받아 지정된 구조에 맞춰 컴포넌트, 스타일, 테스트, 스토리북 파일을 자동으로 생성합니다.

plopfile.js 설정:

```jsx
module.exports = function (plop) {
  plop.setGenerator("component", {
    description: "Create a new React component",
    prompts: [
      {
        type: "input",
        name: "name",
        message: "Component name please",
      },
    ],
    actions: [
      {
        type: "addMany",
        destination: "src/components/{{pascalCase name}}",
        base: "plop-templates/component",
        templateFiles: "plop-templates/component/**",
      },
    ],
  })
}
```

템플릿 파일 (/plop-templates/component/):

{{pascalCase name}}.tsx.hbs:

```
import React from 'react';
import styles from './{{pascalCase name}}.module.css';

export const {{pascalCase name}} = () => {
  return <div className={styles.root}>{{pascalCase name}}</div>;
};

```

{{pascalCase name}}.test.tsx.hbs:

```
import { render } from '@testing-library/react';
import { {{pascalCase name}} } from './{{pascalCase name}}';

it('renders correctly', () => {
  render(<{{pascalCase name}} />);
});

```

{{pascalCase name}}.stories.tsx.hbs:

```
import type { Meta, StoryObj } from '@storybook/react';
import { {{pascalCase name}} } from './{{pascalCase name}}';

const meta: Meta<typeof {{pascalCase name}}> = {
  title: 'Components/{{pascalCase name}}',
  component: {{pascalCase name}},
};
export default meta;

type Story = StoryObj<typeof {{pascalCase name}}>;

export const Default: Story = {};

```

### ESLint를 이용한 경계 정의

**목적을 알아봅시다**: ESLint는 코드 스타일뿐만 아니라 아키텍처 규칙을 강제하는 강력한 도구로 활용될 수 있다는 것을 배웁니다. 잘못된 import 구문을 감지하여 아키텍처의 계층과 모듈 간의 경계를 보호하는 것이 핵심입니다. 예를 들어, features 계층의 한 모듈이 다른 모듈을 직접 임포트하는 것을 금지하거나, 모듈의 내부 파일에 직접 접근하는 것을 막을 수 있습니다.

**기본 규칙: no-restricted-imports를 익혀봅시다**: ESLint에 내장된 이 규칙은 특정 모듈이나 경로 패턴의 임포트를 금지하는 간단하면서도 효과적인 방법을 제공한다는 것을 배웁니다. 예를 들어, onboarding 기능이 dashboard 기능을 임포트하는 것을 막으려면 다음과 같이 설정할 수 있습니다.

```json
{
  "rules": {
    "no-restricted-imports": [
      "error",
      {
        "patterns": [
          {
            "group": ["**/features/dashboard/**"],
            "message": "Dashboard feature cannot be imported by other features."
          }
        ]
      }
    ]
  }
}
```

**고급 플러그인: eslint-plugin-boundaries를 배워봅시다**: 더 복잡하고 정교한 경계 규칙을 위해서는 eslint-plugin-boundaries와 같은 전문 플러그인을 사용하는 것이 좋다는 것을 알게 됩니다. 이 플러그인은 파일 경로를 기반으로 '요소 타입'(예: feature, component, util)을 정의하고, 어떤 타입이 다른 어떤 타입을 임포트할 수 있는지에 대한 허용/금지 규칙을 상세하게 설정할 수 있게 해줍니다. 이는 FSD와 같은 계층적 아키텍처의 의존성 규칙을 코드로 강제하는 데 매우 유용합니다.

**FSD 전용 플러그인을 알아봅시다**: FSD 아키텍처를 채택한 팀을 위해, 경로 검사, 공개 API 강제, 계층 간 임포트 규칙 등을 사전 정의된 규칙으로 제공하는 eslint-plugin-fsd-projects나 eslint-plugin-feature-sliced-design-imports와 같은 전용 ESLint 플러그인도 존재한다는 것을 배웁니다.

이처럼 현대적인 아키텍처 전략은 단순히 폴더 구조를 정의하는 것에서 그치지 않는다는 것을 이해하게 됩니다. 린터와 코드 생성기 같은 도구들은 아키텍처의 '강제 계층(enforcement layer)'을 형성하여, 설계 원칙이 시간이 지나도 무너지지 않도록 보장합니다. 과거에는 아키텍처가 다이어그램으로 문서화되고 코드 리뷰를 통해 수동으로 검증되었다면, 이제는 도구를 통해 개발자의 IDE에서 즉각적인 피드백을 제공하고, 잘못된 구조가 생성되는 것 자체를 방지하는 방식으로 진화했다는 것을 배우게 됩니다. 따라서 2025년의 성공적인 아키텍처 전략은 반드시 그에 상응하는 도구 전략을 포함해야 한다는 중요한 교훈을 얻게 됩니다.

## Part 5: 의사결정 프레임워크 및 권장사항

지금까지 다양한 아키텍처 원칙, 방법론, 프레임워크별 구현 방안을 배워보았습니다. 이 파트에서는 이 모든 학습 내용을 종합하여, 각 프로젝트의 특성에 맞는 최적의 폴더 구조를 선택할 수 있도록 돕는 실용적인 의사결정 프레임워크를 익혀보겠습니다.

### 5.1. 비교 분석 및 장단점

각 아키텍처 접근법의 핵심적인 특징과 장단점을 한눈에 비교할 수 있도록 정리한 표를 살펴봅시다. 이 표는 기술 리더나 아키텍트가 프로젝트의 규모, 복잡성, 팀의 경험 수준과 같은 맥락을 고려하여 전략적인 결정을 내리는 데 유용한 도구가 될 것입니다.

| 접근법                     | 주요 초점             | 이상적인 프로젝트 규모        | 학습 곡선   | ✅ 장점                                                                  | ❌ 단점                                                                                 |
| -------------------------- | --------------------- | ----------------------------- | ----------- | ------------------------------------------------------------------------ | --------------------------------------------------------------------------------------- |
| 플랫 / 타입 기반           | 단순성, 속도          | 소규모 / 프로토타입           | 매우 낮음   | 시작이 빠르고 보일러플레이트가 적음.                                     | 확장이 어렵고 응집도가 낮아 유지보수가 힘듦.                                            |
| 기능 기반                  | 응집도, 유지보수성    | 중규모 ~ 대규모               | 낮음 ~ 중간 | 높은 응집도, 기능 단위 탐색 및 리팩토링 용이.                            | 규칙 없이는 비일관적으로 변질될 수 있으며, '기능'과 '공유'의 경계가 모호해질 수 있음.   |
| 아토믹 디자인              | UI 재사용성, 일관성   | 모든 규모 (컴포넌트 전략으로) | 중간        | 디자인 시스템 구축에 탁월하며 일관성을 증진시킴.                         | 너무 세분화될 수 있으며, 자체적으로 비즈니스 로직 구성을 해결하지 못함.                 |
| DDD 기반                   | 비즈니스 로직 정렬    | 대규모 / 복잡함               | 높음        | 코드베이스가 비즈니스 도메인과 일치하여 도메인 전문가에게 직관적임.      | 깊은 비즈니스 이해가 필요하며, 잘못 적용될 위험이 있음.                                 |
| 피처 슬라이스 디자인 (FSD) | 엄격한 확장성, 안정성 | 초대규모 / 엔터프라이즈       | 매우 높음   | 극도로 확장 가능하며, 아키텍처 부패를 방지하고 안전한 리팩토링을 보장함. | 가파른 학습 곡선, 높은 보일러플레이트, 소규모 프로젝트에는 과하며, 너무 경직될 수 있음. |

### 5.2. 2025년을 위한 전략적 권장사항

프로젝트의 상황에 따라 다음과 같은 전략적 접근을 권장합니다. 각 상황에 맞는 최적의 선택을 배워봅시다.

**스타트업 및 MVP (Minimum Viable Product)**:
단순한 기능 기반(Feature-Based) 구조로 시작하는 것이 좋다는 것을 배웁니다. FSD와 같은 복잡한 방법론의 오버헤드를 피하고 개발 속도에 집중하되, 향후 확장을 위한 기초를 다지는 것이 중요합니다. 처음부터 `/features` 폴더를 만들어 비즈니스 로직을 분리하고, 진정으로 범용적인 코드만을 위한 `/shared/components`와 `/shared/hooks` 폴더를 운영하는 것이 좋은 출발점입니다.

**중규모 성장 단계의 제품**:
견고한 기능 기반 구조나, 비즈니스 로직이 복잡하다면 DDD 기반 구조가 이상적이라는 것을 알게 됩니다. 이 단계에서는 팀이 성장함에 따라 아키텍처의 일관성을 유지하기 위해 자동화된 규칙을 도입해야 합니다. ESLint 규칙을 설정하여 모듈 간의 부적절한 의존성을 차단하고, Plop.js와 같은 코드 생성기를 도입하여 새로운 기능이나 컴포넌트가 정해진 구조를 따르도록 강제하는 것을 고려해야 한다는 것을 배웁니다.

**대규모 엔터프라이즈 플랫폼 및 다수 팀**:
이것이 바로 **피처 슬라이스 디자인(FSD)과 모노레포 조합이 가장 빛을 발하는 시나리오**라는 것을 이해하게 됩니다. FSD의 엄격함은 더 이상 단점이 아니라, 여러 팀에 걸쳐 장기간에 걸쳐 일관성을 강제하는 강력한 장점이 됩니다. 장기적인 안정성과 유지보수성을 통해 얻는 이점이 크기 때문에, 도구 도입과 팀 교육에 대한 초기 투자는 충분히 정당화됩니다.

**디자인 시스템 구축**:
아키텍처의 중심은 아토믹 디자인이어야 한다는 것을 배웁니다. 일반적으로 모노레포 내의 packages/ui와 같은 독립된 패키지에서 개발되며, 모노레포의 다른 apps들이 이 디자인 시스템 패키지를 소비하는 형태가 됩니다.

**황금률 (The Golden Rule)을 기억하세요**:
React 공식 문서의 "폴더 구조에 5분 이상 고민하지 말라"는 조언은 프로토타입 단계에서는 유효할 수 있습니다. 하지만 실제 장기적인 프로젝트를 위한 진정한 조언은 다음과 같다는 것을 배우게 됩니다:

> "기능 기반 구조로 시작하고, 그 구조가 없어서 겪는 고통이 새로운 구조를 도입하는 비용보다 커질 때에만 점진적으로 복잡성(더 엄격한 계층, 자동화 도구 등)을 추가하라."

## 끝으로…

많은 개발자들이 저마다의 철학을 바탕으로 시행착오를 겪고 있고 그 시행착오들 가운데 더 좋다고 생각하는 것들이 모범사례가 되고 이러한 사례를 학습하고 적용해봅니다. 이러한 모법사례가 언제나 지금의 프로젝트에 딱 맞는 옷은 아니기에 우리는 그 위에 다른 자신만의 철학과 시행착오의 변주를 계속 하게 되는 역사가 반복됩니다.

모범사례의 학습하고 이 방식이 모범사례가 되는 배경을 이해하고 그 배경에 맞게 나의 맥락에 맞게 적용을 하면서 좋은 점과 아쉬운점을 반영하되 아키텍쳐란 함께 하는 것인 만큼 너무 급진적이지 않게 점진적이고 실용적인 접근 방식이 조금씩 키워나가는 시각을 가지게 되기를 바랍니다.

프로젝트의 성장에 맞춰 아키텍처를 진화시키는 것이 핵심이며, 처음부터 모든 것을 완벽하게 설계하려는 시도는 오히려 개발 속도를 저해하고 불필요한 복잡성만 낳을 수 있다는 것을 기억해주세요.

모두 모두 화이팅입니다!
